<!DOCTYPE html>
<html>
<head>
    <title>Lattice Trie Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #graph-container {
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            position: relative;
        }
        .node {
            fill: #69b3a2;
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            transition: fill 0.3s ease, stroke 0.3s ease; /* Added transition for color */
        }
        .node.root { fill: #c6dbef; }
        .node.sink-end-node {
            fill: #ff7f0e;
            stroke: #e0ac2b;
            stroke-width: 3px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.1;
            stroke-width: 1px;
            transition: stroke 0.3s ease, stroke-opacity 0.3s ease; /* Added transition */
        }
        .node-label {
            font-size: 12px;
            fill: #444;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
            transition: opacity 0.3s ease;
        }
        
        /* Hover Box Styles */
        .hover-box {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 300px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
        }
        .hover-box.active { opacity: 1; visibility: visible; }
        .hover-box h4 { margin: 0 0 5px 0; color: #333; }
        .hover-box p { margin: 0; color: #555; font-size: 12px; }

        /* Highlight Styles */
        .node.highlighted { stroke: #e0ac2b; stroke-width: 3px; }
        .node.ancestor { fill: #a1d99b; stroke: #74c476; stroke-width: 2px; }
        .node.descendant { fill: #9ecae1; stroke: #6baed6; stroke-width: 2px; }
        
        .link.highlighted-path { stroke: #e0ac2b; stroke-width: 2.5px; stroke-opacity: 1; }
        .link.ancestor-link { stroke: #74c476; stroke-width: 2px; stroke-opacity: 1; }
        .link.descendant-link { stroke: #6baed6; stroke-width: 2px; stroke-opacity: 1; }

        .node.dimmed { fill: #ccc; stroke: #eee; opacity: 0.1; }
        .link.dimmed { stroke: #ccc; stroke-opacity: 0.05; }
        .node-label.dimmed { opacity: 0; }

        /* --- NEW UI STYLES --- */
        #ui-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: none; /* Hidden by default */
            z-index: 1000;
            max-height: 80vh;
            flex-direction: column;
        }

        #ui-container.visible {
            display: flex;
        }

        button#gen-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
            transition: background-color 0.2s;
        }

        button#gen-btn:hover {
            background-color: #45a049;
        }

        #word-list {
            overflow-y: auto;
            flex-grow: 1;
            border-top: 1px solid #eee;
            margin-top: 5px;
            padding-top: 10px;
        }

        .generated-word {
            display: block;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            margin-bottom: 5px;
            padding: 4px;
            background: #f9f9f9;
            border-radius: 3px;
        }

        /* Color Coding for Text */
        .char-ancestor { color: #74c476; font-weight: bold; } /* Green */
        .char-focus { color: #ff7f0e; font-weight: bold; text-decoration: underline; } /* Orange */
        .char-descendant { color: #6baed6; font-weight: bold; } /* Blue */
        
        .empty-msg { color: #999; font-style: italic; font-size: 12px; text-align: center; }

    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div id="graph-container"></div>
    <div class="hover-box" id="hover-box"></div>

    <div id="ui-container">
        <h3 style="margin-top:0; color:#333;">Subgraph Tools</h3>
        <p style="font-size:12px; color:#666; margin-bottom: 10px;">Node frozen. Generate words passing through this node:</p>
        <button id="gen-btn">Generate Words</button>
        <div id="word-list"></div>
    </div>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select("#graph-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom().on("zoom", function ({ transform }) {
                g.attr("transform", transform);
            }));

        const g = svg.append("g");

        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");
        const hoverBox = d3.select("#hover-box");
        
        // UI Elements
        const uiContainer = d3.select("#ui-container");
        const genBtn = d3.select("#gen-btn");
        const wordList = d3.select("#word-list");

        // FIX 1: Explicitly force hide on load
        uiContainer.style("display", "none");

        let graphNodes = [];
        let graphLinks = [];
        let simulation;

        // --- STATE VARIABLES ---
        let isGraphFrozen = false;
        let frozenNodeId = null;

        // --- CONFIGURATION ---
        const SUBGRAPH_CONFIG = {
            verticalSpacing: 60,
            horizontalSpacing: 40,
            transitionDuration: 500,
            focusStrength: 0.9 
        };

        d3.json(`../lattice_trie_graph.json?t=${new Date().getTime()}`).then(graph => {
            graphNodes = graph.nodes;
            graphLinks = graph.links;

            // --- Layout Logic ---
            const maxLevel = d3.max(graph.nodes, d => d.level);
            const levelToY = d3.scaleLinear()
                .domain([0, maxLevel])
                .range([height * 0.1, height * 0.9]);

            const nodesByLevel = d3.group(graph.nodes, d => d.level);

            nodesByLevel.forEach((nodes, level) => {
                const numNodesOnLevel = nodes.length;
                const startX = (width - (numNodesOnLevel - 1) * 50) / 2;
                nodes.sort((a, b) => a.id - b.id);
                nodes.forEach((node, i) => {
                    node.fx = startX + i * 50;
                    node.fy = levelToY(level);
                    node.originalFx = node.fx;
                    node.originalFy = node.fy;
                    node.x = node.fx;
                    node.y = node.fy;
                });
            });

            simulation = d3.forceSimulation(graph.nodes)
                .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
                .on("tick", ticked);

            // --- Elements ---
            const link = linkGroup
                .selectAll("line")
                .data(graph.links)
                .join("line")
                .attr("class", "link");

            const node = nodeGroup
                .selectAll("circle")
                .data(graph.nodes)
                .join("circle")
                .attr("r", 10)
                .attr("class", d => {
                    let classes = `node`;
                    if (d.name === 'ROOT') classes += ' root';
                    if (d.name === 'END') classes += ' sink-end-node';
                    return classes;
                })
                .on("mouseover", (event, d) => {
                    if (!isGraphFrozen) {
                        highlightGraphSegments(event, d);
                        displayHoverBox(event, d);
                    } else if (d.id === frozenNodeId) {
                        displayHoverBox(event, d);
                    }
                })
                .on("mouseout", (event, d) => {
                    hideHoverBox();
                    if (!isGraphFrozen) {
                        removeGraphHighlights();
                    }
                })
                .on("click", handleNodeClick);

            const nodeLabel = nodeGroup
                .selectAll("text")
                .data(graph.nodes)
                .join("text")
                .attr("class", "node-label")
                .attr("dy", "0.35em")
                .text(d => (d.name === 'ROOT' || d.name === 'END') ? '' : d.name);

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                nodeLabel
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            }

            // --- Word Generation Logic ---
            
            genBtn.on("click", () => {
                if (!frozenNodeId) return;
                const centerNode = graphNodes.find(n => n.id === frozenNodeId);
                if (!centerNode) return;
                
                generateWords(centerNode);
            });

            function generateWords(centerNode) {
                wordList.html(""); // Clear previous

                if (centerNode.name === 'ROOT' || centerNode.name === 'END') {
                    wordList.html("<div class='empty-msg'>Cannot generate words from ROOT or END nodes.</div>");
                    return;
                }

                // 1. Get all paths from ROOT to centerNode (Ancestors)
                const prefixes = findPrefixes(centerNode);
                
                // 2. Get all paths from centerNode to END (Descendants)
                const suffixes = findSuffixes(centerNode);

                // 3. Combine
                let count = 0;
                if (prefixes.length === 0 && suffixes.length === 0) {
                      wordList.html("<div class='empty-msg'>No valid paths found.</div>");
                      return;
                }

                const prefixList = prefixes.length > 0 ? prefixes : [""];
                const suffixList = suffixes.length > 0 ? suffixes : [""];

                prefixList.forEach(pre => {
                    suffixList.forEach(suf => {
                        count++;
                        const div = document.createElement('div');
                        div.className = 'generated-word';
                        
                        // Construct colored HTML
                        const html = `
                            <span class="char-ancestor">${pre}</span><span class="char-focus">${centerNode.name}</span><span class="char-descendant">${suf}</span>
                        `;
                        div.innerHTML = html;
                        wordList.node().appendChild(div);
                    });
                });
            }

            // Backward DFS to finding strings from Root -> Node
            function findPrefixes(targetNode) {
                let results = [];
                
                function backtrack(currentNode, currentString) {
                    const incomingLinks = graphLinks.filter(l => l.target.id === currentNode.id);
                    
                    if (incomingLinks.length === 0) {
                        return;
                    }

                    incomingLinks.forEach(link => {
                        const parent = link.source;
                        if (parent.name === 'ROOT') {
                            results.push(currentString);
                        } else {
                            backtrack(parent, parent.name + currentString);
                        }
                    });
                }

                backtrack(targetNode, "");
                return results;
            }

            // Forward DFS to find strings from Node -> End
            function findSuffixes(sourceNode) {
                let results = [];

                function forward(currentNode, currentString) {
                    const outgoingLinks = graphLinks.filter(l => l.source.id === currentNode.id);

                    outgoingLinks.forEach(link => {
                        const child = link.target;
                        if (child.name === 'END') {
                            results.push(currentString);
                        } else {
                            forward(child, currentString + child.name);
                        }
                    });
                }

                forward(sourceNode, "");
                return results;
            }

            // --- Helper Functions ---
            function getNodeChildren(node, links) {
                return links.filter(link => link.source.id === node.id).map(link => link.target);
            }

            function getNodeDescendants(node, links) {
                const descendants = new Set();
                const queue = [node];
                let head = 0;
                while (head < queue.length) {
                    const currentNode = queue[head++];
                    const children = getNodeChildren(currentNode, links);
                    for (const child of children) {
                        if (!descendants.has(child.id)) {
                            descendants.add(child.id);
                            queue.push(child);
                        }
                    }
                }
                return Array.from(descendants).map(id => graphNodes.find(n => n.id === id));
            }

            function getNodeAncestors(node, links) {
                const ancestors = new Set();
                const queue = [node];
                let head = 0;
                while (head < queue.length) {
                    const currentNode = queue[head++];
                    const parents = links.filter(link => link.target.id === currentNode.id).map(link => link.source);
                    for (const parent of parents) {
                        if (!ancestors.has(parent.id)) {
                            ancestors.add(parent.id);
                            queue.push(parent);
                        }
                    }
                }
                return Array.from(ancestors).map(id => graphNodes.find(n => n.id === id));
            }

            // --- Logic for Mini-Subgraph Calculation ---
            function calculateCompactLayout(centerNode, ancestors, descendants) {
                const layoutMap = new Map();
                layoutMap.set(centerNode.id, { x: centerNode.x, y: centerNode.y });

                const ancestorsByLevel = d3.group(ancestors, d => d.level);
                const ancLevels = Array.from(ancestorsByLevel.keys()).sort((a, b) => b - a);

                ancLevels.forEach(level => {
                    const levelNodes = ancestorsByLevel.get(level);
                    levelNodes.sort((a, b) => a.id - b.id);
                    const levelDiff = centerNode.level - level;
                    const y = centerNode.y - (levelDiff * SUBGRAPH_CONFIG.verticalSpacing);
                    const width = (levelNodes.length - 1) * SUBGRAPH_CONFIG.horizontalSpacing;
                    const startX = centerNode.x - (width / 2);
                    levelNodes.forEach((node, i) => {
                        layoutMap.set(node.id, { x: startX + (i * SUBGRAPH_CONFIG.horizontalSpacing), y: y });
                    });
                });

                const descendantsByLevel = d3.group(descendants, d => d.level);
                const descLevels = Array.from(descendantsByLevel.keys()).sort((a, b) => a - b);

                descLevels.forEach(level => {
                    const levelNodes = descendantsByLevel.get(level);
                    levelNodes.sort((a, b) => a.id - b.id);
                    const levelDiff = level - centerNode.level;
                    const y = centerNode.y + (levelDiff * SUBGRAPH_CONFIG.verticalSpacing);
                    const width = (levelNodes.length - 1) * SUBGRAPH_CONFIG.horizontalSpacing;
                    const startX = centerNode.x - (width / 2);
                    levelNodes.forEach((node, i) => {
                        layoutMap.set(node.id, { x: startX + (i * SUBGRAPH_CONFIG.horizontalSpacing), y: y });
                    });
                });

                return layoutMap;
            }

            // --- Click Handler (Freeze/Unfreeze) ---
            function handleNodeClick(event, d) {
                event.stopPropagation();

                if (isGraphFrozen && frozenNodeId === d.id) {
                    // Unfreeze
                    isGraphFrozen = false;
                    frozenNodeId = null;
                    removeGraphHighlights();
                    hideHoverBox();
                    uiContainer.style("display", "none");
                    wordList.html(""); 
                } else {
                    // Freeze (or switch node)
                    isGraphFrozen = true;
                    frozenNodeId = d.id;
                    
                    highlightGraphSegments(event, d);
                    displayHoverBox(event, d);
                    
                    // Show UI
                    uiContainer.style("display", "flex");
                    wordList.html(""); // Clear old words immediately when switching
                }
            }

            function highlightGraphSegments(event, d) {
                simulation.stop();

                // FIX 2: RESET ALL CLASSES FIRST
                // This ensures that if we are switching from Node A to Node B,
                // Node A's ancestors don't stay colored green.
                node.classed("dimmed", false)
                    .classed("highlighted", false)
                    .classed("ancestor", false)
                    .classed("descendant", false);

                nodeLabel.classed("dimmed", false);

                link.classed("dimmed", false)
                    .classed("highlighted-path", false)
                    .classed("ancestor-link", false)
                    .classed("descendant-link", false);

                // Now calculate new set
                const ancestors = getNodeAncestors(d, graphLinks);
                const descendants = getNodeDescendants(d, graphLinks);
                
                const ancestorIds = new Set(ancestors.map(n => n.id));
                const descendantIds = new Set(descendants.map(n => n.id));
                const allHighlightIds = new Set([d.id, ...ancestorIds, ...descendantIds]);

                const perfectPositions = calculateCompactLayout(d, ancestors, descendants);
                const interpolatedPositions = new Map();
                
                perfectPositions.forEach((target, id) => {
                    const n = graphNodes.find(node => node.id === id);
                    if (n) {
                        const newX = n.originalFx + (target.x - n.originalFx) * SUBGRAPH_CONFIG.focusStrength;
                        const newY = n.originalFy + (target.y - n.originalFy) * SUBGRAPH_CONFIG.focusStrength;
                        interpolatedPositions.set(id, { x: newX, y: newY });
                    }
                });

                // Apply new classes
                node.classed("dimmed", n => !allHighlightIds.has(n.id));
                nodeLabel.classed("dimmed", n => !allHighlightIds.has(n.id));
                
                link.classed("dimmed", l => {
                        const isAncestorLink = ancestorIds.has(l.source.id) && ancestorIds.has(l.target.id);
                        const isDescendantLink = descendantIds.has(l.source.id) && descendantIds.has(l.target.id);
                        const isConnectorUp = l.target.id === d.id && ancestorIds.has(l.source.id);
                        const isConnectorDown = l.source.id === d.id && descendantIds.has(l.target.id);
                        return !(isAncestorLink || isDescendantLink || isConnectorUp || isConnectorDown);
                });

                d3.select(event.currentTarget).classed("highlighted", true);
                node.filter(n => n.id === d.id).classed("highlighted", true);

                node.filter(n => ancestorIds.has(n.id)).classed("ancestor", true);
                node.filter(n => descendantIds.has(n.id)).classed("descendant", true);

                link.classed("ancestor-link", l => (ancestorIds.has(l.source.id) && ancestorIds.has(l.target.id)) || (l.target.id === d.id && ancestorIds.has(l.source.id)));
                link.classed("descendant-link", l => (descendantIds.has(l.source.id) && descendantIds.has(l.target.id)) || (l.source.id === d.id && descendantIds.has(l.target.id)));
                link.classed("highlighted-path", l => (l.source.id === d.id && descendantIds.has(l.target.id)) || (l.target.id === d.id && ancestorIds.has(l.source.id)));

                // Animation
                node.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                    .attr("cx", n => interpolatedPositions.has(n.id) ? interpolatedPositions.get(n.id).x : n.x)
                    .attr("cy", n => interpolatedPositions.has(n.id) ? interpolatedPositions.get(n.id).y : n.y);

                nodeLabel.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                    .attr("x", n => interpolatedPositions.has(n.id) ? interpolatedPositions.get(n.id).x : n.x)
                    .attr("y", n => interpolatedPositions.has(n.id) ? interpolatedPositions.get(n.id).y : n.y);

                link.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                    .attr("x1", l => interpolatedPositions.has(l.source.id) ? interpolatedPositions.get(l.source.id).x : l.source.x)
                    .attr("y1", l => interpolatedPositions.has(l.source.id) ? interpolatedPositions.get(l.source.id).y : l.source.y)
                    .attr("x2", l => interpolatedPositions.has(l.target.id) ? interpolatedPositions.get(l.target.id).x : l.target.x)
                    .attr("y2", l => interpolatedPositions.has(l.target.id) ? interpolatedPositions.get(l.target.id).y : l.target.y);
            }

            function removeGraphHighlights() {
                if (isGraphFrozen) return;

                node.attr("class", n => {
                    let classes = `node`;
                    if (n.name === 'ROOT') classes += ' root';
                    if (n.name === 'END') classes += ' sink-end-node';
                    return classes;
                });
                nodeLabel.attr("class", "node-label");
                link.attr("class", "link");

                const t = d3.transition().duration(SUBGRAPH_CONFIG.transitionDuration);

                node.transition(t)
                    .attr("cx", d => d.originalFx)
                    .attr("cy", d => d.originalFy);
                
                nodeLabel.transition(t)
                    .attr("x", d => d.originalFx)
                    .attr("y", d => d.originalFy);

                link.transition(t)
                    .attr("x1", d => d.source.originalFx)
                    .attr("y1", d => d.source.originalFy)
                    .attr("x2", d => d.target.originalFx)
                    .attr("y2", d => d.target.originalFy)
                    .on("end", () => {
                        graphNodes.forEach(n => {
                            n.x = n.originalFx;
                            n.y = n.originalFy;
                        });
                        simulation.alpha(0.1).restart();
                    });
            }

            // --- Tooltip Logic ---
            let hideHoverBoxTimeout = null;

            function displayHoverBox(event, d) {
                if (hideHoverBoxTimeout) {
                    clearTimeout(hideHoverBoxTimeout);
                    hideHoverBoxTimeout = null;
                }
                hoverBox.style("visibility", "visible");
                hoverBox.classed("active", true);
                
                let content = `<h4>Node: "${d.name}" (ID: ${d.id})</h4>`;
                content += `<p>Level: ${d.level}</p>`;
                hoverBox.html(content);
                moveHoverBox(event);
            }

            function hideHoverBox() {
                hoverBox.classed("active", false);
                if (hideHoverBoxTimeout) {
                    clearTimeout(hideHoverBoxTimeout);
                }
                hideHoverBoxTimeout = setTimeout(() => {
                    if (!hoverBox.classed("active")) {
                        hoverBox.style("visibility", "hidden");
                    }
                    hideHoverBoxTimeout = null;
                }, 200);
            }

            function moveHoverBox(event) {
                const x = event.pageX + 10;
                const y = event.pageY + 10;
                hoverBox.style("left", `${x}px`).style("top", `${y}px`);
            }

            // Background Click -> Unfreeze All
            svg.on("click", (event) => {
                const targetTag = event.target.tagName;
                if (targetTag !== "circle" && isGraphFrozen) {
                    isGraphFrozen = false;
                    frozenNodeId = null;
                    removeGraphHighlights();
                    hideHoverBox();
                    // Hide UI on bg click
                    uiContainer.style("display", "none");
                    wordList.html("");
                }
            });
        });
    </script>
</body>
</html>