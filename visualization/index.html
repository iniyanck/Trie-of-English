<!DOCTYPE html>
<html>
<head>
    <title>Lattice Trie Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #graph-container {
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            position: relative;
        }
        .node {
            fill: #69b3a2;
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            /* Removed transitions here to allow D3 to control attributes directly for the movement */
        }
        .node.root { fill: #c6dbef; }
        .node.sink-end-node {
            fill: #ff7f0e;
            stroke: #e0ac2b;
            stroke-width: 3px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.1;
            stroke-width: 1px;
        }
        .node-label {
            font-size: 12px;
            fill: #444;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
            transition: opacity 0.3s ease; /* Keep opacity transition */
        }
        
        /* Hover Box Styles */
        .hover-box {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 300px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
        }
        .hover-box.active { opacity: 1; visibility: visible; }
        .hover-box h4 { margin: 0 0 5px 0; color: #333; }
        .hover-box p { margin: 0; color: #555; font-size: 12px; }

        /* Highlight Styles */
        .node.highlighted { stroke: #e0ac2b; stroke-width: 3px; }
        .node.ancestor { fill: #a1d99b; stroke: #74c476; stroke-width: 2px; }
        .node.descendant { fill: #9ecae1; stroke: #6baed6; stroke-width: 2px; }
        
        .link.highlighted-path { stroke: #e0ac2b; stroke-width: 2.5px; stroke-opacity: 1; }
        .link.ancestor-link { stroke: #74c476; stroke-width: 2px; stroke-opacity: 1; }
        .link.descendant-link { stroke: #6baed6; stroke-width: 2px; stroke-opacity: 1; }

        .node.dimmed { fill: #ccc; stroke: #eee; opacity: 0.1; }
        .link.dimmed { stroke: #ccc; stroke-opacity: 0.05; }
        .node-label.dimmed { opacity: 0; }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div id="graph-container"></div>
    <div class="hover-box" id="hover-box"></div>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select("#graph-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom().on("zoom", function ({ transform }) {
                g.attr("transform", transform);
            }));

        const g = svg.append("g");

        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");
        const hoverBox = d3.select("#hover-box");

        let graphNodes = [];
        let graphLinks = [];
        let simulation;

        // Configuration for the mini-subgraph layout
        const SUBGRAPH_CONFIG = {
            verticalSpacing: 60,   // Vertical distance between levels
            horizontalSpacing: 40, // Horizontal distance between siblings
            transitionDuration: 500 // Animation speed in ms
        };

        d3.json(`../lattice_trie_graph.json?t=${new Date().getTime()}`).then(graph => {
            graphNodes = graph.nodes;
            graphLinks = graph.links;

            // --- Layout Logic ---
            const maxLevel = d3.max(graph.nodes, d => d.level);
            const levelToY = d3.scaleLinear()
                .domain([0, maxLevel])
                .range([height * 0.1, height * 0.9]);

            const nodesByLevel = d3.group(graph.nodes, d => d.level);

            nodesByLevel.forEach((nodes, level) => {
                const numNodesOnLevel = nodes.length;
                const startX = (width - (numNodesOnLevel - 1) * 50) / 2;
                nodes.sort((a, b) => a.id - b.id);
                nodes.forEach((node, i) => {
                    node.fx = startX + i * 50;
                    node.fy = levelToY(level);
                    // STORE ORIGINAL POSITIONS FOR RESTORATION
                    node.originalFx = node.fx;
                    node.originalFy = node.fy;
                    // Initialize current position to target to prevent jump on load
                    node.x = node.fx;
                    node.y = node.fy;
                });
            });

            simulation = d3.forceSimulation(graph.nodes)
                .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
                .on("tick", ticked);

            // --- Elements ---
            const link = linkGroup
                .selectAll("line")
                .data(graph.links)
                .join("line")
                .attr("class", "link");

            const node = nodeGroup
                .selectAll("circle")
                .data(graph.nodes)
                .join("circle")
                .attr("r", 10)
                .attr("class", d => {
                    let classes = `node`;
                    if (d.name === 'ROOT') classes += ' root';
                    if (d.name === 'END') classes += ' sink-end-node';
                    return classes;
                })
                .on("mouseover", highlightGraphSegments)
                .on("mouseout", function(event, d) {
                    removeGraphHighlights();
                    hideHoverBox();
                })
                .on("click", toggleHoverBox);

            const nodeLabel = nodeGroup
                .selectAll("text")
                .data(graph.nodes)
                .join("text")
                .attr("class", "node-label")
                .attr("dy", "0.35em")
                .text(d => (d.name === 'ROOT' || d.name === 'END') ? '' : d.name);

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                nodeLabel
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            }

            // --- Helper Functions ---

            function getNodeChildren(node, links) {
                return links.filter(link => link.source.id === node.id).map(link => link.target);
            }

            function getNodeDescendants(node, links) {
                const descendants = new Set();
                const queue = [node];
                let head = 0;
                while (head < queue.length) {
                    const currentNode = queue[head++];
                    const children = getNodeChildren(currentNode, links);
                    for (const child of children) {
                        if (!descendants.has(child.id)) {
                            descendants.add(child.id);
                            queue.push(child);
                        }
                    }
                }
                return Array.from(descendants).map(id => graphNodes.find(n => n.id === id));
            }

            function getNodeAncestors(node, links) {
                const ancestors = new Set();
                const queue = [node];
                let head = 0;
                while (head < queue.length) {
                    const currentNode = queue[head++];
                    const parents = links.filter(link => link.target.id === currentNode.id).map(link => link.source);
                    for (const parent of parents) {
                        if (!ancestors.has(parent.id)) {
                            ancestors.add(parent.id);
                            queue.push(parent);
                        }
                    }
                }
                return Array.from(ancestors).map(id => graphNodes.find(n => n.id === id));
            }

            // --- Logic for Mini-Subgraph Calculation ---
            function calculateCompactLayout(centerNode, ancestors, descendants) {
                const layoutMap = new Map(); // Store id -> {x, y}

                // 1. Position Center Node (Keep it where it is or center of screen? Let's keep it where it is)
                layoutMap.set(centerNode.id, { x: centerNode.x, y: centerNode.y });

                // 2. Position Ancestors (Above center)
                const ancestorsByLevel = d3.group(ancestors, d => d.level);
                // Sort levels descending (closest to node first)
                const ancLevels = Array.from(ancestorsByLevel.keys()).sort((a, b) => b - a);

                ancLevels.forEach(level => {
                    const levelNodes = ancestorsByLevel.get(level);
                    levelNodes.sort((a, b) => a.id - b.id); // consistent sort
                    
                    const levelDiff = centerNode.level - level;
                    const y = centerNode.y - (levelDiff * SUBGRAPH_CONFIG.verticalSpacing);
                    
                    // Center horizontally relative to parent
                    const width = (levelNodes.length - 1) * SUBGRAPH_CONFIG.horizontalSpacing;
                    const startX = centerNode.x - (width / 2);

                    levelNodes.forEach((node, i) => {
                        layoutMap.set(node.id, {
                            x: startX + (i * SUBGRAPH_CONFIG.horizontalSpacing),
                            y: y
                        });
                    });
                });

                // 3. Position Descendants (Below center)
                const descendantsByLevel = d3.group(descendants, d => d.level);
                const descLevels = Array.from(descendantsByLevel.keys()).sort((a, b) => a - b);

                descLevels.forEach(level => {
                    const levelNodes = descendantsByLevel.get(level);
                    levelNodes.sort((a, b) => a.id - b.id);

                    const levelDiff = level - centerNode.level;
                    const y = centerNode.y + (levelDiff * SUBGRAPH_CONFIG.verticalSpacing);

                    const width = (levelNodes.length - 1) * SUBGRAPH_CONFIG.horizontalSpacing;
                    const startX = centerNode.x - (width / 2);

                    levelNodes.forEach((node, i) => {
                        layoutMap.set(node.id, {
                            x: startX + (i * SUBGRAPH_CONFIG.horizontalSpacing),
                            y: y
                        });
                    });
                });

                return layoutMap;
            }

            let activeHoverBoxNode = null;
            let hideHoverBoxTimeout = null;

            function highlightGraphSegments(event, d) {
                if (activeHoverBoxNode !== d.id) {
                    // STOP SIMULATION to take manual control of positions
                    simulation.stop();

                    const ancestors = getNodeAncestors(d, graphLinks);
                    const descendants = getNodeDescendants(d, graphLinks);
                    
                    const ancestorIds = new Set(ancestors.map(n => n.id));
                    const descendantIds = new Set(descendants.map(n => n.id));
                    const allHighlightIds = new Set([d.id, ...ancestorIds, ...descendantIds]);

                    // Calculate the new compact positions
                    const targetPositions = calculateCompactLayout(d, ancestors, descendants);

                    // --- Apply Classes (Visuals) ---
                    node.classed("dimmed", n => !allHighlightIds.has(n.id));
                    nodeLabel.classed("dimmed", n => !allHighlightIds.has(n.id));
                    
                    // Simple Logic: Dim all links not involved
                    link.classed("dimmed", l => {
                         const isAncestorLink = ancestorIds.has(l.source.id) && ancestorIds.has(l.target.id);
                         const isDescendantLink = descendantIds.has(l.source.id) && descendantIds.has(l.target.id);
                         const isConnectorUp = l.target.id === d.id && ancestorIds.has(l.source.id);
                         const isConnectorDown = l.source.id === d.id && descendantIds.has(l.target.id);
                         return !(isAncestorLink || isDescendantLink || isConnectorUp || isConnectorDown);
                    });

                    // Highlight specific types
                    d3.select(event.currentTarget).classed("highlighted", true);
                    node.filter(n => ancestorIds.has(n.id)).classed("ancestor", true);
                    node.filter(n => descendantIds.has(n.id)).classed("descendant", true);

                    link.classed("ancestor-link", l => (ancestorIds.has(l.source.id) && ancestorIds.has(l.target.id)) || (l.target.id === d.id && ancestorIds.has(l.source.id)));
                    link.classed("descendant-link", l => (descendantIds.has(l.source.id) && descendantIds.has(l.target.id)) || (l.source.id === d.id && descendantIds.has(l.target.id)));
                    link.classed("highlighted-path", l => (l.source.id === d.id && descendantIds.has(l.target.id)) || (l.target.id === d.id && ancestorIds.has(l.source.id)));

                    // --- Animate Positions (Motion) ---
                    
                    // 1. Move Nodes
                    node.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                        .attr("cx", n => {
                            if (targetPositions.has(n.id)) return targetPositions.get(n.id).x;
                            return n.x; // Stay in current spot if dimmed
                        })
                        .attr("cy", n => {
                            if (targetPositions.has(n.id)) return targetPositions.get(n.id).y;
                            return n.y; // Stay in current spot if dimmed
                        });

                    // 2. Move Labels
                    nodeLabel.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                        .attr("x", n => targetPositions.has(n.id) ? targetPositions.get(n.id).x : n.x)
                        .attr("y", n => targetPositions.has(n.id) ? targetPositions.get(n.id).y : n.y);

                    // 3. Move Links
                    link.transition().duration(SUBGRAPH_CONFIG.transitionDuration)
                        .attr("x1", l => targetPositions.has(l.source.id) ? targetPositions.get(l.source.id).x : l.source.x)
                        .attr("y1", l => targetPositions.has(l.source.id) ? targetPositions.get(l.source.id).y : l.source.y)
                        .attr("x2", l => targetPositions.has(l.target.id) ? targetPositions.get(l.target.id).x : l.target.x)
                        .attr("y2", l => targetPositions.has(l.target.id) ? targetPositions.get(l.target.id).y : l.target.y);
                }
            }

            function removeGraphHighlights() {
                // Reset Classes
                node.attr("class", n => {
                    let classes = `node`;
                    if (n.name === 'ROOT') classes += ' root';
                    if (n.name === 'END') classes += ' sink-end-node';
                    return classes;
                });
                nodeLabel.attr("class", "node-label");
                link.attr("class", "link");

                // --- Animate Back to Original Grid ---
                
                const t = d3.transition().duration(SUBGRAPH_CONFIG.transitionDuration);

                node.transition(t)
                    .attr("cx", d => d.originalFx)
                    .attr("cy", d => d.originalFy);
                
                nodeLabel.transition(t)
                    .attr("x", d => d.originalFx)
                    .attr("y", d => d.originalFy);

                link.transition(t)
                    .attr("x1", d => d.source.originalFx)
                    .attr("y1", d => d.source.originalFy)
                    .attr("x2", d => d.target.originalFx)
                    .attr("y2", d => d.target.originalFy)
                    .on("end", () => {
                        // Optional: Restart simulation tick if needed, though for a static grid 
                        // updating x/y data to match the visual fx/fy is good practice.
                        graphNodes.forEach(n => {
                            n.x = n.originalFx;
                            n.y = n.originalFy;
                        });
                        // Restarting isn't strictly necessary if we trust the transition,
                        // but ensures data consistency for the force engine.
                        simulation.alpha(0.1).restart();
                    });
            }

            // ... (Hover box functions remain identical to your original code) ...
            function displayHoverBox(event, d) {
                if (hideHoverBoxTimeout) {
                    clearTimeout(hideHoverBoxTimeout);
                    hideHoverBoxTimeout = null;
                }
                hoverBox.style("visibility", "visible");
                hoverBox.classed("active", true);
                
                let content = `<h4>Node: "${d.name}" (ID: ${d.id})</h4>`;
                content += `<p>Level: ${d.level}</p>`;
                hoverBox.html(content);
                moveHoverBox(event);
            }

            function hideHoverBox() {
                hoverBox.classed("active", false);
                if (hideHoverBoxTimeout) {
                    clearTimeout(hideHoverBoxTimeout);
                    hideHoverBoxTimeout = null;
                }
                hideHoverBoxTimeout = setTimeout(() => {
                    if (!hoverBox.classed("active")) {
                        hoverBox.style("visibility", "hidden");
                    }
                    hideHoverBoxTimeout = null;
                }, 200);
                activeHoverBoxNode = null;
            }

            function moveHoverBox(event) {
                const x = event.pageX + 10;
                const y = event.pageY + 10;
                hoverBox.style("left", `${x}px`).style("top", `${y}px`);
            }

            function toggleHoverBox(event, d) {
                if (activeHoverBoxNode === d.id) {
                    hideHoverBox();
                } else {
                    displayHoverBox(event, d);
                    activeHoverBoxNode = d.id;
                }
                event.stopPropagation();
            }

            svg.on("click", (event) => {
                if (event.target.tagName !== "circle" && activeHoverBoxNode !== null) {
                    hideHoverBox();
                }
            });
        });
    </script>
</body>
</html>